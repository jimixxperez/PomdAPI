{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#pomdapi","title":"PomdAPI","text":"<p>PomdAPI is a Python library built to bring a FastAPI-style developer experience to creating strongly-typed API clients. </p> <p>We love the clarity and ergonomics FastAPI introduced for web apps, especially with its Pydantic-based approach. But when we needed a similar, no-nonsense way to define and manage multi-protocol API calls\u2014HTTP, JSON-RPC, XML-RPC\u2014we couldn\u2019t find anything that \u201cjust worked\u201d without getting tangled in repetitive logic.</p> <p>So we built PomdAPI with one simple goal:</p> <p>deliver that same clean, efficient feeling to any kind of API interaction. Whether you prefer sync or async, need caching and invalidation, or want a clear, typed model for requests and responses, PomdAPI aims to make it all painless and Pythonic. We hope it becomes your go-to solution for taming multi-protocol APIs with minimal fuss.</p>"},{"location":"#why-use-pomdapi","title":"Why use PomdAPI?","text":"<p>\ud83c\udfaf  Declarative Endpoints Define your queries and mutations in a single, clear place using decorators. This means you can outline how to fetch or update data\u2014whether it\u2019s GitHub issues or Ethereum balances\u2014without repeating request logic.</p> <p>\ud83d\ude80  Pluggable Protocols Enjoy out-of-the-box support for HTTP, JSON-RPC, and XML-RPC calls, with a straightforward pattern for adding any custom protocol. All protocols share the same consistent API interface, so you can reuse logic and tooling across diverse data sources.</p> <p>\ud83d\udd12  Built-In Caching Built with Python type hints and Pydantic models, giving you both compile-time checks and runtime validation. This helps prevent bugs and ensures predictable data structures across your codebase.</p> <p>\u26a1  Automatic Sync/Async Use the same function in synchronous or asynchronous contexts\u2014no code duplication necessary. Whether you\u2019re in a simple script or an async-based web framework, the library adapts seamlessly.</p> <p>\ud83d\udd16  Tag-Based Invalidation Speed up your application by reducing unnecessary requests and handling partial data updates. Choose from in-memory, Memcached, Redis, or implement your own custom caching backend.</p> <p>\ud83d\udd16  Expandable Architecture Assign tags to endpoints, then invalidate entire lists or single items by tag. This makes cache updates straightforward and more maintainable for dynamic data.</p> <p>Whether you\u2019re building a small prototype or a large-scale service, these features help keep your code clean, consistent, and reliable. For more hands-on guides, check out our Getting Started page or explore the Examples of how you can integrate PomdAPI into real-world projects.</p> <p>To learn more about each feature, check out our Features page or dive straight into the Getting Started guide.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>In Beta</p> <p>PomdAPI is in early beta, the API might be still subject to change.</p> <pre><code>from pomdapi.api.http import HttpApi, RequestDefinition\nfrom pomdapi.cache.in_memory import InMemoryCache\n\n# Create an API instance with in-memory caching\napi = HttpApi.from_defaults(\n    base_query_config=BaseQueryConfig(base_url=\"https://api.example.com\"),\n    cache=InMemoryCache()\n)\n\n# Define deserialized response type\nclass UserProfile(BaseModel):\n    id_: str = Field(alias=\"id\")\n    name: str\n    age: int\n\n# Define a query endpoint\n@api.query(\"getUserProfile\", response_type=UserProfile)\ndef get_user_profile(user_id: str):\n    return RequestDefinition(\n        method=\"GET\",\n        url=f\"/users/{user_id}\"\n    )\n\n\n# Use the function in the default async context\nasync def main():\n    profile = await get_user_profile(user_id=\"123\") \n    print(profile)\n\n# or in a sync context\ndef main():\n    profile = get_user_profile(is_async=False, user_id=\"123\")\n    print(profile)\n</code></pre>"},{"location":"#fastapi-vs-pomdapi-an-inversion","title":"FastAPI vs. PomdAPI: An Inversion","text":"<p>FastAPI is a server framework that uses parameter decorators to build endpoints. For example, you write code like:</p> FastAPI <pre><code>from fastapi import FastAPI\napp = FastAPI()\n\n@app.get(\"/item/{item_id}\")\ndef read_user(item_id: int):\n  ...\n</code></pre> <p>Here, FastAPI uses the function signature (e.g., item_id, q) to parse incoming requests, inject them as arguments, and produce a server response.</p> PomdAPI <p><pre><code>from pomdapi.api.http import HttpApi\n\napi = HttpApi(...)\n\n@api.query(\"getItem\")\ndef get_item(item_id: str, q: str | None = None):\n    return RequestDefinition(\n        method=\"GET\",\n        url=\"/items/{item_id}\",\n    )\n  )\n</code></pre> PomdAPI, by contrast, does the client-side inverse. You define a function that takes parameters (like item_id, q), and the library uses them to build the outgoing request to a server</p> FastAPI (Server) PomdAPI (Client) What it does? Exposes a path like /items/{item_id}. The function runs when that path is requested. Parametrizes a client call to that path (or another remote service). The function returns a \u201crequest definition\u201d that includes how to fetch or mutate data. Parameter usage Extract request parameters from path/query, injecting them into the function signature. Use function parameters to dynamically build the request config\u2014URL, method, etc. The library then executes the request and returns (or caches) the response. Result A server-side function that runs for incoming requests. A client-side function that makes requests to a remote server, with caching and tagging built-in. <p>Conclusion</p> <p>By removing the heavy lifting typically associated with data fetching and caching logic, this library lets you focus on delivering value to your users. It leverages a modular and type-friendly architecture, supports multiple transport protocols, and offers both sync and async flows to fit a variety of Python use cases\u2014all in one cohesive package.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"features/","title":"Features","text":"<p>Papperlapi helps you build typed API clients with out-of-the-box support for both synchronous and asynchronous usage, powerful caching, and intuitive configuration. Below are the major features that set Papperlapi apart.</p>"},{"location":"features/#synchronous-asynchronous-calls","title":"Synchronous &amp; Asynchronous Calls","text":"<p>One of papperlapi\u2019s standout features is that any query or mutation endpoint can be used synchronously or asynchronously\u2014no separate code paths required!</p> <p>Example:</p> <p><pre><code>from papperlapi.core.types import Tag\nfrom papperlapi.api.http import HttpApi, RequestDefinition\nfrom papperlapi.cache.in_memory import InMemoryCache\n\napi = HttpApi.from_defaults(..., cache=InMemoryCache())\n\n@api.query(\"getData\", response_type=dict)\ndef get_data(param: str):\n    return RequestDefinition(\n        method=\"GET\",\n        url=f\"/data?param={param}\",\n    )\n\n# Synchronous usage:\nresult_sync = get_data(is_async=False, param=\"test\")\nprint(\"Sync result:\", result_sync)\n\n# Asynchronous usage:\nimport asyncio\n\nasync def main():\n    result_async = await get_data(param=\"async-test\")\n    print(\"Async result:\", result_async)\n\nasyncio.run(main())\n</code></pre> What\u2019s happening:</p> <ul> <li><code>@api.query(...)</code> registers an endpoint named \"getData\".</li> <li>We invoke <code>get_data(is_async=False, ...)</code> to run it synchronously.</li> <li>We then invoke <code>await get_data(...)</code> for the asynchronous version\u2014no extra code needed.</li> </ul>"},{"location":"features/#typed-endpoints-with-pydantic","title":"Typed Endpoints with Pydantic","text":"<p>papperlapi integrates neatly with Pydantic, ensuring your API responses match a specified schema. If the JSON from the server doesn\u2019t match your model, a validation error is raised\u2014preventing silent failures.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n\n@api.query(\"getUser\", response_type=User)\ndef get_user(user_id: int):\n    return RequestDefinition(\n        method=\"GET\",\n        url=f\"/users/{user_id}\",\n    )\n\n# Let's make a synchronous call for demonstration\nuser = get_user(is_async=False, user_id=42)\nprint(\"User:\", user)\nprint(\"User type:\", type(user))  # &lt;class '__main__.User'&gt;\n</code></pre>"},{"location":"features/#tag-based-caching-and-invalidation","title":"Tag-Based Caching and Invalidation","text":"<p>papperlapi uses tags to track cached items. Queries \u201cprovide\u201d tags, mutations \u201cinvalidate\u201d them\u2014so it\u2019s easy to refetch only what\u2019s needed when data changes.</p> <pre><code>from papperlapi.core.types import Tag\n\n@api.query(\"getRepoIssue\", response_type=dict)\ndef get_repo_issue(owner: str, repo: str, issue_number: int):\n    # Provide a tag for this issue\n    return (\n        RequestDefinition(\n            method=\"GET\",\n            url=f\"/repos/{owner}/{repo}/issues/{issue_number}\",\n        ),\n        Tag(type=\"Issue\", id=str(issue_number))\n    )\n\n@api.mutation(\"closeIssue\")\ndef close_issue(owner: str, repo: str, issue_number: int):\n    # Invalidate the single-issue tag\n    return (\n        RequestDefinition(\n            method=\"PATCH\",\n            url=f\"/repos/{owner}/{repo}/issues/{issue_number}\",\n            body={\"state\": \"closed\"},\n        ),\n        Tag(type=\"Issue\", id=str(issue_number))\n    )\n\n# Now, if we call close_issue, papperlapi invalidates that specific issue in the cache\nclose_issue(is_async=False, owner=\"octocat\", repo=\"hello-world\", issue_number=42)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with the API library.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>First, install the package using pip:</p> <pre><code>pip install papperlapi \n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-an-api-instance","title":"Creating an API Instance","text":"<pre><code>from api.http import HttpApi\nfrom core.types import BaseQueryConfig\n\napi = HttpApi.from_defaults(\n    base_query_config=BaseQueryConfig(\n        base_url=\"https://api.example.com\"\n    )\n)\n</code></pre>"},{"location":"getting-started/#defining-queries","title":"Defining Queries","text":"<pre><code>from typing import List\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    name: str\n    email: str\n\n@api.query(\"getUsers\", response_type=List[User])\ndef get_users():\n    return {\"path\": \"/users\"}\n</code></pre>"},{"location":"getting-started/#using-mutations","title":"Using Mutations","text":"<pre><code>@api.mutation(\"createUser\", response_type=User)\ndef create_user(name: str, email: str):\n    return {\n        \"path\": \"/users\",\n        \"method\": \"POST\",\n        \"body\": {\"name\": name, \"email\": email}\n    }\n</code></pre>"},{"location":"getting-started/#adding-caching","title":"Adding Caching","text":"<pre><code>from cache.in_memory import InMemoryCache\n\napi = HttpApi.from_defaults(\n    base_query_config=BaseQueryConfig(\n        base_url=\"https://api.example.com\"\n    ),\n    cache=InMemoryCache()\n)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out the API Reference for detailed documentation</li> <li>See Examples for practical use cases</li> <li>Learn about Caching options</li> </ul>"},{"location":"install/","title":"Install","text":""},{"location":"install/#installation","title":"Installation","text":"<pre><code>pip/uv-add pomdapi\n</code></pre>"},{"location":"references/api_http/","title":"Api","text":"<p>This section documents the <code>Api</code> class and related functionality from <code>api.http</code>.</p>"},{"location":"references/api_http/#pomdapi.api.http.RequestDefinition","title":"<code>RequestDefinition</code>  <code>dataclass</code>","text":"<p>Defines a request for the API.</p> Source code in <code>src/pomdapi/api/http.py</code> <pre><code>@dataclass\nclass RequestDefinition:\n    \"\"\"Defines a request for the API.\"\"\"\n\n    method: Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n    url: str\n    body: Any = None\n    headers: dict[str, str] = field(default_factory=dict)\n</code></pre>"},{"location":"references/core_api/","title":"Core API","text":"<p>This section documents the <code>Api</code> class and related functionality from <code>core.api</code>.</p>"},{"location":"references/core_api/#pomdapi.core.api.Api","title":"<code>Api</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[EndpointDefinitionGen, BaseQueryConfig, TResponse]</code></p> <p>The Api class is the main entry point for interacting with the API. It provides a simple interface for defining query and mutation endpoints.</p> <p>This class is generic over two type parameters: - EndpointDefinitionGen: The type of request definition (e.g., HTTP request, RPC request) - TResponse: The type of response returned by the API</p> <p>Attributes:</p> Name Type Description <code>base_query_config</code> <code>BaseQueryConfig</code> <p>Configuration for all API requests</p> <code>base_query_fn_handler</code> <code>BaseQueryFn[BaseQueryConfig, EndpointDefinitionGen, TResponse] | None</code> <p>Synchronous function to execute requests</p> <code>base_query_fn_handler_async</code> <code>Optional[BaseQueryFnAsync[BaseQueryConfig, EndpointDefinitionGen, TResponse]]</code> <p>Asynchronous function to execute requests</p> <code>endpoints</code> <code>dict[str, EndpointDefinition[EndpointDefinitionGen]]</code> <p>Dictionary mapping endpoint names to their definitions</p> <code>cache</code> <code>Optional[Cache[EndpointDefinitionGen, TResponse]]</code> <p>Optional cache implementation for responses</p> Example <pre><code>api = Api(\n    base_query_config=BaseQueryConfig(base_url=\"https://api.example.com\"),\n    cache=InMemoryCache()\n)\n\n@api.query(\"getUser\", response_type=User)\ndef get_user(id: str):\n    return {\"path\": f\"/users/{id}\"}\n</code></pre> Source code in <code>src/pomdapi/core/api.py</code> <pre><code>@dataclass\nclass Api(Generic[EndpointDefinitionGen, BaseQueryConfig, TResponse]):\n    \"\"\"\n    The Api class is the main entry point for interacting with the API.\n    It provides a simple interface for defining query and mutation endpoints.\n\n    This class is generic over two type parameters:\n    - EndpointDefinitionGen: The type of request definition (e.g., HTTP request, RPC request)\n    - TResponse: The type of response returned by the API\n\n    Attributes:\n        base_query_config: Configuration for all API requests\n        base_query_fn_handler: Synchronous function to execute requests\n        base_query_fn_handler_async: Asynchronous function to execute requests\n        endpoints: Dictionary mapping endpoint names to their definitions\n        cache: Optional cache implementation for responses\n\n    Example:\n        ```python\n        api = Api(\n            base_query_config=BaseQueryConfig(base_url=\"https://api.example.com\"),\n            cache=InMemoryCache()\n        )\n\n        @api.query(\"getUser\", response_type=User)\n        def get_user(id: str):\n            return {\"path\": f\"/users/{id}\"}\n        ```\n    \"\"\"\n\n    base_query_config: BaseQueryConfig\n    base_query_fn_handler: BaseQueryFn[\n        BaseQueryConfig, EndpointDefinitionGen, TResponse\n    ] | None = None\n    base_query_fn_handler_async: Optional[\n        BaseQueryFnAsync[BaseQueryConfig, EndpointDefinitionGen, TResponse]\n    ] = None\n    endpoints: dict[str, EndpointDefinition[EndpointDefinitionGen]] = field(\n        default_factory=dict\n    )\n    cache: Optional[Cache[EndpointDefinitionGen, TResponse]] = None\n\n    def base_query_fn(\n        self, fn: BaseQueryFn[BaseQueryConfig, EndpointDefinitionGen, TResponse]\n    ) -&gt; BaseQueryFn[BaseQueryConfig, EndpointDefinitionGen, TResponse]:\n        \"\"\"Decorator to register a base query function.\"\"\"\n        if not self.base_query_fn_handler:\n            self.base_query_fn_handler = fn\n        return fn\n\n    def query(\n        self,\n        name: str,\n        response_type: Type[ResponseType],\n    ) -&gt; Callable[\n        [\n            Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n        ],\n        SyncAsync[QueryParam, ResponseType],\n    ]:\n        \"\"\"Decorator to register a query endpoint.\n        The decorated function will execute the query and return the response.\n        \"\"\"\n\n        def decorator(\n            fn: Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]],\n        ) -&gt; SyncAsync[QueryParam, ResponseType]:\n            endpoint = EndpointDefinition(\n                request_fn=fn,\n                is_query_endpoint=True,\n            )\n            self.endpoints[name] = endpoint\n\n            if TYPE_CHECKING:\n\n                @overload\n                def wrapper(\n                    is_async: Literal[False],\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; ResponseType:\n                    ...\n\n                @overload\n                def wrapper(\n                    is_async: Literal[True] = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[ResponseType]:\n                    ...\n\n                @overload\n                def wrapper(\n                    is_async: bool = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[ResponseType] | ResponseType:\n                    ...\n\n            @wraps(fn)\n            def wrapper(\n                is_async: bool = True,\n                *args: QueryParam.args,\n                **kwargs: QueryParam.kwargs,\n            ) -&gt; asyncio.Future[ResponseType] | ResponseType:\n                if is_async:\n\n                    async def _run() -&gt; ResponseType:\n                        response = await self.run_query(\n                            is_async=True, endpoint_name=name, *args, **kwargs\n                        )\n                        if isinstance(response_type, BaseModel):\n                            return response_type.model_validate(response)\n                        adapter = TypeAdapter(response_type)\n                        return adapter.validate_python(response)\n\n                    return asyncio.ensure_future(_run())\n\n                response = self.run_query(\n                    is_async=False, endpoint_name=name, *args, **kwargs\n                )\n\n                if isinstance(response_type, BaseModel):\n                    return response_type.model_validate(response)\n                adapter = TypeAdapter(response_type)\n                return adapter.validate_python(response)\n\n            return wrapper\n\n        return decorator\n\n    @overload\n    def mutation(\n        self,\n        name: str,\n        response_type: Type[ResponseType],\n    ) -&gt; Callable[\n        [\n            Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n        ],\n        SyncAsync[QueryParam, ResponseType],\n    ]:\n        ...\n\n    @overload\n    def mutation(\n        self,\n        name: str,\n        response_type: Literal[None] = None,\n    ) -&gt; Callable[\n        [\n            Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n        ],\n        SyncAsync[QueryParam, None],\n    ]:\n        ...\n\n    @overload\n    def mutation(\n        self,\n        name: str,\n        response_type: Type[ResponseType] | None = None,\n    ) -&gt; Callable[\n        [\n            Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n        ],\n        SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None],\n    ]:\n        ...\n\n    def mutation(\n        self,\n        name: str,\n        response_type: Type[ResponseType] | None = None,\n    ) -&gt; Callable[\n        [\n            Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n        ],\n        SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None],\n    ]:\n        \"\"\"Decorator to register a mutation endpoint.\n        The decorated function will execute the mutation and return the response.\n        \"\"\"\n\n        def decorator(\n            fn: Callable[QueryParam, EndpointDefinitionGen]\n            | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]],\n        ) -&gt; SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None]:\n            endpoint = EndpointDefinition(\n                request_fn=fn,\n                is_query_endpoint=False,\n            )\n            self.endpoints[name] = endpoint\n\n            if response_type is None:\n                if TYPE_CHECKING:\n\n                    @overload\n                    def none_wrapper(\n                        is_async: Literal[False],\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; None:\n                        ...\n\n                    @overload\n                    def none_wrapper(\n                        is_async: Literal[True] = True,\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; asyncio.Future[None]:\n                        ...\n\n                    @overload\n                    def none_wrapper(\n                        is_async: bool = True,\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; asyncio.Future[None] | None:\n                        ...\n\n                @wraps(fn)\n                def none_wrapper(\n                    is_async: bool, *args, **kwargs\n                ) -&gt; asyncio.Future[None] | (None):\n                    if is_async:\n\n                        async def _run() -&gt; None:\n                            await self.run_mutation(\n                                is_async=True, endpoint_name=name, *args, **kwargs\n                            )\n                            return None\n\n                        return asyncio.ensure_future(_run())\n\n                    self.run_mutation(\n                        is_async=False, endpoint_name=name, *args, **kwargs\n                    )\n                    return None\n\n                return none_wrapper\n\n            else:\n                if TYPE_CHECKING:\n\n                    @overload\n                    def wrapper(\n                        is_async: Literal[False],\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; ResponseType:\n                        ...\n\n                    @overload\n                    def wrapper(\n                        is_async: Literal[True] = True,\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; asyncio.Future[ResponseType]:\n                        ...\n\n                    @overload\n                    def wrapper(\n                        is_async: bool = True,\n                        *args: QueryParam.args,\n                        **kwargs: QueryParam.kwargs,\n                    ) -&gt; asyncio.Future[ResponseType] | (ResponseType):\n                        ...\n\n                @wraps(fn)\n                def wrapper(\n                    is_async: bool, *args, **kwargs\n                ) -&gt; asyncio.Future[ResponseType] | (ResponseType):\n                    if is_async:\n\n                        async def _run() -&gt; ResponseType:\n                            response = await self.run_mutation(\n                                is_async=True, endpoint_name=name, *args, **kwargs\n                            )\n\n                            if isinstance(response_type, BaseModel):\n                                return response_type.model_validate(response)\n\n                            adapter = TypeAdapter(response_type)\n                            return adapter.validate_python(response)\n\n                        return asyncio.ensure_future(_run())\n\n                    response = self.run_mutation(\n                        is_async=False, endpoint_name=name, *args, **kwargs\n                    )\n\n                    if isinstance(response_type, BaseModel):\n                        return response_type.model_validate(response)\n\n                    adapter = TypeAdapter(response_type)\n                    return adapter.validate_python(response)\n\n                return wrapper\n\n        return decorator\n\n    @overload\n    def run_query(\n        self, is_async: Literal[False], endpoint_name: str, *args, **kwargs\n    ) -&gt; TResponse:\n        ...\n\n    @overload\n    def run_query(\n        self, is_async: Literal[True], endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse]:\n        ...\n\n    @overload\n    def run_query(\n        self, is_async: bool, endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse] | TResponse:\n        ...\n\n    def run_query(\n        self, is_async: bool, endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse] | TResponse:\n        if self.base_query_fn is None:\n            raise ValueError(\"base_query function is not set.\")\n\n        endpoint = self.endpoints.get(endpoint_name)\n        if endpoint is None or not endpoint.is_query:\n            raise ValueError(f\"No query endpoint named '{endpoint_name}' found.\")\n\n        request_def_and_tags = endpoint.request_fn(*args, **kwargs)\n        tags = None\n        if isinstance(request_def_and_tags, tuple):\n            request_def, tags = request_def_and_tags\n            if callable(tags):\n                tags = tags(*args, **kwargs)\n            if not isinstance(tags, Iterable):\n                tags = [tags]\n        else:\n            request_def = cast(EndpointDefinitionGen, request_def_and_tags)\n\n        if self.cache:\n            cached_response = self.cache.get_by_request(endpoint_name, request_def)\n            if cached_response is not None:\n                return cached_response\n\n        assert self.base_query_fn_handler\n        if is_async:\n\n            async def _run() -&gt; TResponse:\n                assert self.base_query_fn_handler_async is not None\n                if is_base_query_fn_async_arity_2(self.base_query_fn_handler_async):\n                    response = await self.base_query_fn_handler_async(\n                        self.base_query_config, request_def\n                    )\n                else:\n                    response = await self.base_query_fn_handler_async(\n                        self.base_query_config, request_def, endpoint_name # type: ignore\n                    ) \n\n                if self.cache:\n                    await self.cache.aset(\n                        endpoint_name=endpoint_name,\n                        request=request_def,\n                        response=response,\n                        tags=tags and tags or [],\n                    )\n                return response\n\n            return asyncio.ensure_future(_run())\n\n        # GET Number of parameters\n        # fn_sig = inspect.signature(self.base_query_fn_handler)\n        if is_base_query_fn_arity_2(self.base_query_fn_handler):\n            response = self.base_query_fn_handler(self.base_query_config, request_def)\n        else:\n            response = self.base_query_fn_handler(\n                self.base_query_config, request_def, endpoint_name # type: ignore\n            )\n        # if len(fn_sig.parameters) == 3:\n        #    fn = cast(Callable[[BaseQueryConfig, EndpointDefinitionGen, str], TResponse], self.base_query_fn_handler)\n        #    response = fn(self.base_query_config, request_def, endpoint_name)\n        # else:\n        #    fn = cast(Callable[[BaseQueryConfig, EndpointDefinitionGen], TResponse], self.base_query_fn_handler)\n        #    response = fn(self.base_query_config, request_def)\n\n        if self.cache:\n            self.cache.set(\n                endpoint_name=endpoint_name,\n                request=request_def,\n                response=response,\n                tags=tags and tags or [],\n            )\n        return response\n\n    @overload\n    def run_mutation(\n        self, is_async: Literal[False], endpoint_name: str, *args, **kwargs\n    ) -&gt; TResponse:\n        ...\n\n    @overload\n    def run_mutation(\n        self, is_async: Literal[True], endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse]:\n        ...\n\n    @overload\n    def run_mutation(\n        self, is_async: bool, endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse] | TResponse:\n        ...\n\n    def run_mutation(\n        self, is_async: bool, endpoint_name: str, *args, **kwargs\n    ) -&gt; asyncio.Future[TResponse] | TResponse:\n        if self.base_query_fn is None:\n            raise ValueError(\"base_query function is not set.\")\n\n        endpoint = self.endpoints.get(endpoint_name)\n        if endpoint is None or not endpoint.is_mutation:\n            raise ValueError(f\"No mutation endpoint named '{endpoint_name}' found.\")\n\n        request_def_and_tags = endpoint.request_fn(*args, **kwargs)\n        tags = None\n        if isinstance(request_def_and_tags, tuple):\n            request_def, tags = request_def_and_tags\n            if callable(tags):\n                tags = tags(*args, **kwargs)\n            if not isinstance(tags, Iterable):\n                tags = [tags]\n        else:\n            request_def = cast(EndpointDefinitionGen, request_def_and_tags)\n        assert self.base_query_fn_handler\n        if is_async:\n\n            async def _run() -&gt; TResponse:\n                assert self.base_query_fn_handler_async is not None\n                if is_base_query_fn_async_arity_2(self.base_query_fn_handler_async):\n                    response = await self.base_query_fn_handler_async(\n                        self.base_query_config,\n                        request_def,\n                    )\n                else:\n                    response = await self.base_query_fn_handler_async(\n                        self.base_query_config,\n                        request_def,\n                        endpoint_name, # type: ignore\n                    )\n                if self.cache and tags:\n                    await self.cache.ainvalidate_tags(\n                        endpoint_name=endpoint_name,\n                        tags=tags,\n                    )\n                return response\n\n            return asyncio.ensure_future(_run())\n\n        if is_base_query_fn_arity_2(self.base_query_fn_handler):\n            response = self.base_query_fn_handler(self.base_query_config, request_def)\n        else:\n            response = self.base_query_fn_handler(\n                self.base_query_config, request_def, endpoint_name # type: ignore\n            )\n\n        if self.cache and tags:\n            self.cache.invalidate_tags(\n                endpoint_name=endpoint_name,\n                tags=tags,\n            )\n        return response\n</code></pre>"},{"location":"references/core_api/#pomdapi.core.api.Api.base_query_fn","title":"<code>base_query_fn(fn)</code>","text":"<p>Decorator to register a base query function.</p> Source code in <code>src/pomdapi/core/api.py</code> <pre><code>def base_query_fn(\n    self, fn: BaseQueryFn[BaseQueryConfig, EndpointDefinitionGen, TResponse]\n) -&gt; BaseQueryFn[BaseQueryConfig, EndpointDefinitionGen, TResponse]:\n    \"\"\"Decorator to register a base query function.\"\"\"\n    if not self.base_query_fn_handler:\n        self.base_query_fn_handler = fn\n    return fn\n</code></pre>"},{"location":"references/core_api/#pomdapi.core.api.Api.mutation","title":"<code>mutation(name, response_type=None)</code>","text":"<pre><code>mutation(name: str, response_type: Type[ResponseType]) -&gt; Callable[[Callable[QueryParam, EndpointDefinitionGen] | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]], SyncAsync[QueryParam, ResponseType]]\n</code></pre><pre><code>mutation(name: str, response_type: Literal[None] = None) -&gt; Callable[[Callable[QueryParam, EndpointDefinitionGen] | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]], SyncAsync[QueryParam, None]]\n</code></pre><pre><code>mutation(name: str, response_type: Type[ResponseType] | None = None) -&gt; Callable[[Callable[QueryParam, EndpointDefinitionGen] | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]], SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None]]\n</code></pre> <p>Decorator to register a mutation endpoint. The decorated function will execute the mutation and return the response.</p> Source code in <code>src/pomdapi/core/api.py</code> <pre><code>def mutation(\n    self,\n    name: str,\n    response_type: Type[ResponseType] | None = None,\n) -&gt; Callable[\n    [\n        Callable[QueryParam, EndpointDefinitionGen]\n        | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n    ],\n    SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None],\n]:\n    \"\"\"Decorator to register a mutation endpoint.\n    The decorated function will execute the mutation and return the response.\n    \"\"\"\n\n    def decorator(\n        fn: Callable[QueryParam, EndpointDefinitionGen]\n        | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]],\n    ) -&gt; SyncAsync[QueryParam, ResponseType] | SyncAsync[QueryParam, None]:\n        endpoint = EndpointDefinition(\n            request_fn=fn,\n            is_query_endpoint=False,\n        )\n        self.endpoints[name] = endpoint\n\n        if response_type is None:\n            if TYPE_CHECKING:\n\n                @overload\n                def none_wrapper(\n                    is_async: Literal[False],\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; None:\n                    ...\n\n                @overload\n                def none_wrapper(\n                    is_async: Literal[True] = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[None]:\n                    ...\n\n                @overload\n                def none_wrapper(\n                    is_async: bool = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[None] | None:\n                    ...\n\n            @wraps(fn)\n            def none_wrapper(\n                is_async: bool, *args, **kwargs\n            ) -&gt; asyncio.Future[None] | (None):\n                if is_async:\n\n                    async def _run() -&gt; None:\n                        await self.run_mutation(\n                            is_async=True, endpoint_name=name, *args, **kwargs\n                        )\n                        return None\n\n                    return asyncio.ensure_future(_run())\n\n                self.run_mutation(\n                    is_async=False, endpoint_name=name, *args, **kwargs\n                )\n                return None\n\n            return none_wrapper\n\n        else:\n            if TYPE_CHECKING:\n\n                @overload\n                def wrapper(\n                    is_async: Literal[False],\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; ResponseType:\n                    ...\n\n                @overload\n                def wrapper(\n                    is_async: Literal[True] = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[ResponseType]:\n                    ...\n\n                @overload\n                def wrapper(\n                    is_async: bool = True,\n                    *args: QueryParam.args,\n                    **kwargs: QueryParam.kwargs,\n                ) -&gt; asyncio.Future[ResponseType] | (ResponseType):\n                    ...\n\n            @wraps(fn)\n            def wrapper(\n                is_async: bool, *args, **kwargs\n            ) -&gt; asyncio.Future[ResponseType] | (ResponseType):\n                if is_async:\n\n                    async def _run() -&gt; ResponseType:\n                        response = await self.run_mutation(\n                            is_async=True, endpoint_name=name, *args, **kwargs\n                        )\n\n                        if isinstance(response_type, BaseModel):\n                            return response_type.model_validate(response)\n\n                        adapter = TypeAdapter(response_type)\n                        return adapter.validate_python(response)\n\n                    return asyncio.ensure_future(_run())\n\n                response = self.run_mutation(\n                    is_async=False, endpoint_name=name, *args, **kwargs\n                )\n\n                if isinstance(response_type, BaseModel):\n                    return response_type.model_validate(response)\n\n                adapter = TypeAdapter(response_type)\n                return adapter.validate_python(response)\n\n            return wrapper\n\n    return decorator\n</code></pre>"},{"location":"references/core_api/#pomdapi.core.api.Api.query","title":"<code>query(name, response_type)</code>","text":"<p>Decorator to register a query endpoint. The decorated function will execute the query and return the response.</p> Source code in <code>src/pomdapi/core/api.py</code> <pre><code>def query(\n    self,\n    name: str,\n    response_type: Type[ResponseType],\n) -&gt; Callable[\n    [\n        Callable[QueryParam, EndpointDefinitionGen]\n        | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]]\n    ],\n    SyncAsync[QueryParam, ResponseType],\n]:\n    \"\"\"Decorator to register a query endpoint.\n    The decorated function will execute the query and return the response.\n    \"\"\"\n\n    def decorator(\n        fn: Callable[QueryParam, EndpointDefinitionGen]\n        | Callable[QueryParam, ProvidesTags[EndpointDefinitionGen, QueryParam]],\n    ) -&gt; SyncAsync[QueryParam, ResponseType]:\n        endpoint = EndpointDefinition(\n            request_fn=fn,\n            is_query_endpoint=True,\n        )\n        self.endpoints[name] = endpoint\n\n        if TYPE_CHECKING:\n\n            @overload\n            def wrapper(\n                is_async: Literal[False],\n                *args: QueryParam.args,\n                **kwargs: QueryParam.kwargs,\n            ) -&gt; ResponseType:\n                ...\n\n            @overload\n            def wrapper(\n                is_async: Literal[True] = True,\n                *args: QueryParam.args,\n                **kwargs: QueryParam.kwargs,\n            ) -&gt; asyncio.Future[ResponseType]:\n                ...\n\n            @overload\n            def wrapper(\n                is_async: bool = True,\n                *args: QueryParam.args,\n                **kwargs: QueryParam.kwargs,\n            ) -&gt; asyncio.Future[ResponseType] | ResponseType:\n                ...\n\n        @wraps(fn)\n        def wrapper(\n            is_async: bool = True,\n            *args: QueryParam.args,\n            **kwargs: QueryParam.kwargs,\n        ) -&gt; asyncio.Future[ResponseType] | ResponseType:\n            if is_async:\n\n                async def _run() -&gt; ResponseType:\n                    response = await self.run_query(\n                        is_async=True, endpoint_name=name, *args, **kwargs\n                    )\n                    if isinstance(response_type, BaseModel):\n                        return response_type.model_validate(response)\n                    adapter = TypeAdapter(response_type)\n                    return adapter.validate_python(response)\n\n                return asyncio.ensure_future(_run())\n\n            response = self.run_query(\n                is_async=False, endpoint_name=name, *args, **kwargs\n            )\n\n            if isinstance(response_type, BaseModel):\n                return response_type.model_validate(response)\n            adapter = TypeAdapter(response_type)\n            return adapter.validate_python(response)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"references/core_caching/","title":"Core Caching","text":""},{"location":"references/core_caching/#pomdapi.core.caching.Cache","title":"<code>Cache</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[EndpointDefinitionGen, TResponse]</code></p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>@dataclass\nclass Cache(Generic[EndpointDefinitionGen, TResponse]):\n    _backend: CacheBackend\n    _ttl: int = 60\n\n    @staticmethod\n    def key_from_req(endpoint_name: str, request: EndpointDefinitionGen) -&gt; str:\n        return f\"{endpoint_name}/{request}\"\n\n    @staticmethod\n    def key_from_tag(tag: str | Tag) -&gt; str:\n        return f\"tag/{tag}\"\n\n    def get_by_request(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n    ) -&gt; Optional[TResponse]:\n        key = self.key_from_req(endpoint_name, request)\n        return self._backend.get(key)\n\n    async def aget_by_request(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n    ) -&gt; Optional[TResponse]:\n        \"\"\"Get a response from the cache by request.\"\"\"\n        key = self.key_from_req(endpoint_name, request)\n        return await self._backend.aget(key)\n\n    def get_by_tags(\n        self,\n        endpoint_name: str,\n        tags: Iterable[str | Tag],\n    ) -&gt; Optional[TResponse]:\n        \"\"\"Get a response from the cache by tags.\"\"\"\n        for tag in tags:\n            key = self.key_from_tag(tag)\n            if response := self._backend.get(key):\n                return response\n\n    async def aget_by_tags(\n        self,\n        endpoint_name: str,\n        tags: Iterable[str | Tag],\n    ) -&gt; Optional[TResponse]:\n        \"\"\"Get a response from the cache by tags.\"\"\"\n        for tag in tags:\n            key = self.key_from_tag(tag)\n            if response := await self._backend.aget(key):\n                return response\n\n    def set(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n        tags: Iterable[str | Tag],\n        response: TResponse,\n        ttl: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Set a response in the cache.\"\"\"\n        request_key = self.key_from_req(endpoint_name, request)\n        self._backend.set(request_key, response, ttl=ttl)\n        for tag in tags:\n            key = self.key_from_tag(tag)\n            self._backend.set(key, request_key, ttl=ttl)\n\n    async def aset(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n        tags: Iterable[str | Tag],\n        response: TResponse,\n        ttl: Optional[int] = None,\n    ) -&gt; None:\n        \"\"\"Set a response in the cache.\"\"\"\n        request_def_key = self.key_from_req(endpoint_name, request)\n        async with asyncio.TaskGroup() as tg:\n            tg.create_task(self._backend.aset(request_def_key, response, ttl=ttl))\n            for tag in tags:\n                key = self.key_from_tag(tag)\n                tg.create_task(self._backend.aset(key, request_def_key, ttl=ttl))\n\n    def invalidate_tags(self, endpoint_name: str, tags: Iterable[str | Tag]) -&gt; None:\n        \"\"\"Invalidate a response from the cache by tags.\"\"\"\n        for i, tag in enumerate(tags):\n            tag_key = self.key_from_tag(tag)\n            if i == 0:\n                if (request_key := self._backend.get(tag_key)):\n                    self._backend.delete(request_key)\n            self._backend.delete(tag_key)\n\n    async def ainvalidate_tags(\n        self, endpoint_name: str, tags: Iterable[str | Tag]\n    ) -&gt; None:\n        \"\"\"Invalidate a response from the cache by tags.\"\"\"\n        async with asyncio.TaskGroup() as tg:\n            for i, tag in enumerate(tags):\n                tag_key = self.key_from_tag(tag)\n                if i == 0:\n                    if (request_key := await self._backend.aget(tag_key)):\n                        tg.create_task(self._backend.adelete(request_key))\n                tg.create_task(self._backend.adelete(tag_key))\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.aget_by_request","title":"<code>aget_by_request(endpoint_name, request)</code>  <code>async</code>","text":"<p>Get a response from the cache by request.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def aget_by_request(\n    self,\n    endpoint_name: str,\n    request: EndpointDefinitionGen,\n) -&gt; Optional[TResponse]:\n    \"\"\"Get a response from the cache by request.\"\"\"\n    key = self.key_from_req(endpoint_name, request)\n    return await self._backend.aget(key)\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.aget_by_tags","title":"<code>aget_by_tags(endpoint_name, tags)</code>  <code>async</code>","text":"<p>Get a response from the cache by tags.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def aget_by_tags(\n    self,\n    endpoint_name: str,\n    tags: Iterable[str | Tag],\n) -&gt; Optional[TResponse]:\n    \"\"\"Get a response from the cache by tags.\"\"\"\n    for tag in tags:\n        key = self.key_from_tag(tag)\n        if response := await self._backend.aget(key):\n            return response\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.ainvalidate_tags","title":"<code>ainvalidate_tags(endpoint_name, tags)</code>  <code>async</code>","text":"<p>Invalidate a response from the cache by tags.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def ainvalidate_tags(\n    self, endpoint_name: str, tags: Iterable[str | Tag]\n) -&gt; None:\n    \"\"\"Invalidate a response from the cache by tags.\"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for i, tag in enumerate(tags):\n            tag_key = self.key_from_tag(tag)\n            if i == 0:\n                if (request_key := await self._backend.aget(tag_key)):\n                    tg.create_task(self._backend.adelete(request_key))\n            tg.create_task(self._backend.adelete(tag_key))\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.aset","title":"<code>aset(endpoint_name, request, tags, response, ttl=None)</code>  <code>async</code>","text":"<p>Set a response in the cache.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def aset(\n    self,\n    endpoint_name: str,\n    request: EndpointDefinitionGen,\n    tags: Iterable[str | Tag],\n    response: TResponse,\n    ttl: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Set a response in the cache.\"\"\"\n    request_def_key = self.key_from_req(endpoint_name, request)\n    async with asyncio.TaskGroup() as tg:\n        tg.create_task(self._backend.aset(request_def_key, response, ttl=ttl))\n        for tag in tags:\n            key = self.key_from_tag(tag)\n            tg.create_task(self._backend.aset(key, request_def_key, ttl=ttl))\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.get_by_tags","title":"<code>get_by_tags(endpoint_name, tags)</code>","text":"<p>Get a response from the cache by tags.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def get_by_tags(\n    self,\n    endpoint_name: str,\n    tags: Iterable[str | Tag],\n) -&gt; Optional[TResponse]:\n    \"\"\"Get a response from the cache by tags.\"\"\"\n    for tag in tags:\n        key = self.key_from_tag(tag)\n        if response := self._backend.get(key):\n            return response\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.invalidate_tags","title":"<code>invalidate_tags(endpoint_name, tags)</code>","text":"<p>Invalidate a response from the cache by tags.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def invalidate_tags(self, endpoint_name: str, tags: Iterable[str | Tag]) -&gt; None:\n    \"\"\"Invalidate a response from the cache by tags.\"\"\"\n    for i, tag in enumerate(tags):\n        tag_key = self.key_from_tag(tag)\n        if i == 0:\n            if (request_key := self._backend.get(tag_key)):\n                self._backend.delete(request_key)\n        self._backend.delete(tag_key)\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.Cache.set","title":"<code>set(endpoint_name, request, tags, response, ttl=None)</code>","text":"<p>Set a response in the cache.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def set(\n    self,\n    endpoint_name: str,\n    request: EndpointDefinitionGen,\n    tags: Iterable[str | Tag],\n    response: TResponse,\n    ttl: Optional[int] = None,\n) -&gt; None:\n    \"\"\"Set a response in the cache.\"\"\"\n    request_key = self.key_from_req(endpoint_name, request)\n    self._backend.set(request_key, response, ttl=ttl)\n    for tag in tags:\n        key = self.key_from_tag(tag)\n        self._backend.set(key, request_key, ttl=ttl)\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend","title":"<code>CacheBackend</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for cache backends.</p> <p>Implementations must provide both synchronous and asynchronous methods for basic cache operations (get, set, delete).</p> <p>Methods:</p> Name Description <code>delete</code> <p>Synchronously remove an item from cache</p> <code>adelete</code> <p>Asynchronously remove an item from cache</p> <code>get</code> <p>Synchronously retrieve an item from cache</p> <code>aget</code> <p>Asynchronously retrieve an item from cache</p> <code>set</code> <p>Synchronously store an item in cache with optional TTL</p> <code>aset</code> <p>Asynchronously store an item in cache with optional TTL</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>class CacheBackend(Protocol):\n    \"\"\"Protocol defining the interface for cache backends.\n\n    Implementations must provide both synchronous and asynchronous methods\n    for basic cache operations (get, set, delete).\n\n    Methods:\n        delete: Synchronously remove an item from cache\n        adelete: Asynchronously remove an item from cache\n        get: Synchronously retrieve an item from cache\n        aget: Asynchronously retrieve an item from cache\n        set: Synchronously store an item in cache with optional TTL\n        aset: Asynchronously store an item in cache with optional TTL\n    \"\"\"\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Synchronously delete a cache entry by key.\"\"\"\n        ...\n\n    async def adelete(self, key: str) -&gt; None:\n        \"\"\"Asynchronously delete a cache entry by key.\"\"\"\n        ...\n\n    def get(self, key: str) -&gt; Optional[Any]:\n        \"\"\"Synchronously get a cache entry by key.\"\"\"\n        ...\n\n    async def aget(self, key: str) -&gt; Optional[Any]:\n        \"\"\"Asynchronously get a cache entry by key.\"\"\"\n        ...\n\n    def set(self, key: str, value: Any, ttl: Optional[int] = None) -&gt; None:\n        \"\"\"Synchronously set a cache entry with optional TTL in seconds.\"\"\"\n        ...\n\n    async def aset(\n        self, key: str, value: Any, ttl: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Asynchronously set a cache entry with optional TTL in seconds.\"\"\"\n        ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.adelete","title":"<code>adelete(key)</code>  <code>async</code>","text":"<p>Asynchronously delete a cache entry by key.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"Asynchronously delete a cache entry by key.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.aget","title":"<code>aget(key)</code>  <code>async</code>","text":"<p>Asynchronously get a cache entry by key.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"Asynchronously get a cache entry by key.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.aset","title":"<code>aset(key, value, ttl=None)</code>  <code>async</code>","text":"<p>Asynchronously set a cache entry with optional TTL in seconds.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, ttl: Optional[int] = None\n) -&gt; None:\n    \"\"\"Asynchronously set a cache entry with optional TTL in seconds.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.delete","title":"<code>delete(key)</code>","text":"<p>Synchronously delete a cache entry by key.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"Synchronously delete a cache entry by key.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.get","title":"<code>get(key)</code>","text":"<p>Synchronously get a cache entry by key.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"Synchronously get a cache entry by key.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_caching/#pomdapi.core.caching.CacheBackend.set","title":"<code>set(key, value, ttl=None)</code>","text":"<p>Synchronously set a cache entry with optional TTL in seconds.</p> Source code in <code>src/pomdapi/core/caching.py</code> <pre><code>def set(self, key: str, value: Any, ttl: Optional[int] = None) -&gt; None:\n    \"\"\"Synchronously set a cache entry with optional TTL in seconds.\"\"\"\n    ...\n</code></pre>"},{"location":"references/core_types/","title":"Core Types","text":""},{"location":"references/core_types/#pomdapi.core.types.AyncCachingStrategy","title":"<code>AyncCachingStrategy</code>","text":"<p>               Bases: <code>Protocol[EndpointDefinitionGen, TResponse]</code></p> <p>Defines a caching strategy for the API.</p> Source code in <code>src/pomdapi/core/types.py</code> <pre><code>class AyncCachingStrategy(Protocol[EndpointDefinitionGen, TResponse]):\n    \"\"\"Defines a caching strategy for the API.\"\"\"\n\n    def get(\n        self, endpoint_name: str, request: EndpointDefinitionGen\n    ) -&gt; Optional[TResponse]: ...\n\n    def aset(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n        response: TResponse,\n        tags: list[str],\n    ) -&gt; None: ...\n\n    def invalidate_tags(self, tags: list[str]) -&gt; None: ...\n</code></pre>"},{"location":"references/core_types/#pomdapi.core.types.BaseQueryConfig","title":"<code>BaseQueryConfig</code>  <code>dataclass</code>","text":"<p>Defines the base configuration for all API requests.</p> <p>This class holds common configuration that applies to all requests made through the API, such as base URL and header preparation.</p> <p>Attributes:</p> Name Type Description <code>base_url</code> <code>Optional[str]</code> <p>The base URL for all API requests. If provided, this will be      prepended to all request paths.</p> <code>prepare_headers</code> <code>Callable[[dict[str, str]], dict[str, str]]</code> <p>A callable that takes and returns a headers dictionary.            Use this to add authentication, content-type, or other            headers to all requests.</p> Example <pre><code>config = BaseQueryConfig(\n    base_url=\"https://api.example.com/v1\",\n    prepare_headers=lambda headers: {\n        **headers,\n        \"Authorization\": f\"Bearer {token}\"\n    }\n)\n</code></pre> Source code in <code>src/pomdapi/core/types.py</code> <pre><code>@dataclass\nclass BaseQueryConfig:\n    \"\"\"Defines the base configuration for all API requests.\n\n    This class holds common configuration that applies to all requests made through\n    the API, such as base URL and header preparation.\n\n    Attributes:\n        base_url: The base URL for all API requests. If provided, this will be\n                 prepended to all request paths.\n        prepare_headers: A callable that takes and returns a headers dictionary.\n                       Use this to add authentication, content-type, or other\n                       headers to all requests.\n\n    Example:\n        ```python\n        config = BaseQueryConfig(\n            base_url=\"https://api.example.com/v1\",\n            prepare_headers=lambda headers: {\n                **headers,\n                \"Authorization\": f\"Bearer {token}\"\n            }\n        )\n        ```\n    \"\"\"\n    base_url: Optional[str] = None\n    prepare_headers: Callable[[dict[str, str]], dict[str, str]] = field(\n        default_factory=lambda: lambda header: header\n    )\n</code></pre>"},{"location":"references/core_types/#pomdapi.core.types.EndpointDefinition","title":"<code>EndpointDefinition</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[EndpointDefinitionGen]</code></p> <p>Defines an endpoint for the API.</p> Source code in <code>src/pomdapi/core/types.py</code> <pre><code>@dataclass\nclass EndpointDefinition(Generic[EndpointDefinitionGen]):\n    \"\"\"Defines an endpoint for the API.\"\"\"\n\n    request_fn: (\n        Callable[..., EndpointDefinitionGen]\n        | Callable[..., ProvidesTags[EndpointDefinitionGen, ...]]\n    )\n    is_query_endpoint: bool = True\n\n    @property\n    def is_query(self) -&gt; bool:\n        \"\"\"Returns True if the endpoint is a query endpoint.\"\"\"\n        return self.is_query_endpoint\n\n    @property\n    def is_mutation(self) -&gt; bool:\n        \"\"\"Returns True if the endpoint is a mutation endpoint.\"\"\"\n        return not self.is_query_endpoint\n</code></pre>"},{"location":"references/core_types/#pomdapi.core.types.EndpointDefinition.is_mutation","title":"<code>is_mutation</code>  <code>property</code>","text":"<p>Returns True if the endpoint is a mutation endpoint.</p>"},{"location":"references/core_types/#pomdapi.core.types.EndpointDefinition.is_query","title":"<code>is_query</code>  <code>property</code>","text":"<p>Returns True if the endpoint is a query endpoint.</p>"},{"location":"references/core_types/#pomdapi.core.types.yncCachingStrategy","title":"<code>yncCachingStrategy</code>","text":"<p>               Bases: <code>Protocol[EndpointDefinitionGen, TResponse]</code></p> <p>Defines a caching strategy for the API.</p> Source code in <code>src/pomdapi/core/types.py</code> <pre><code>class yncCachingStrategy(Protocol[EndpointDefinitionGen, TResponse]):\n    \"\"\"Defines a caching strategy for the API.\"\"\"\n\n    def get(\n        self, endpoint_name: str, request: EndpointDefinitionGen\n    ) -&gt; Optional[TResponse]: ...\n\n    def set(\n        self,\n        endpoint_name: str,\n        request: EndpointDefinitionGen,\n        response: TResponse,\n        tags: list[str],\n    ) -&gt; None: ...\n\n    def invalidate_tags(self, tags: list[str]) -&gt; None: ...\n</code></pre>"}]}